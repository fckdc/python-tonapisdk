# coding: utf-8

"""
    REST api to TON blockchain explorer

    Provide access to indexed TON blockchain  # noqa: E501

    The version of the OpenAPI document: 2.0.0
    Contact: support@tonkeeper.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
from fdtapi.models.account_address import AccountAddress
from fdtapi.models.account_status import AccountStatus
from fdtapi.models.action_phase import ActionPhase
from fdtapi.models.bounce_phase_type import BouncePhaseType
from fdtapi.models.compute_phase import ComputePhase
from fdtapi.models.credit_phase import CreditPhase
from fdtapi.models.message import Message
from fdtapi.models.storage_phase import StoragePhase
from fdtapi.models.transaction_type import TransactionType

class Transaction(BaseModel):
    """
    Transaction
    """
    hash: StrictStr = Field(...)
    lt: StrictInt = Field(...)
    account: AccountAddress = Field(...)
    success: StrictBool = Field(...)
    utime: StrictInt = Field(...)
    orig_status: AccountStatus = Field(...)
    end_status: AccountStatus = Field(...)
    total_fees: StrictInt = Field(...)
    transaction_type: TransactionType = Field(...)
    state_update_old: StrictStr = Field(...)
    state_update_new: StrictStr = Field(...)
    in_msg: Optional[Message] = None
    out_msgs: conlist(Message) = Field(...)
    block: StrictStr = Field(...)
    prev_trans_hash: Optional[StrictStr] = None
    prev_trans_lt: Optional[StrictInt] = None
    compute_phase: Optional[ComputePhase] = None
    storage_phase: Optional[StoragePhase] = None
    credit_phase: Optional[CreditPhase] = None
    action_phase: Optional[ActionPhase] = None
    bounce_phase: Optional[BouncePhaseType] = None
    aborted: StrictBool = Field(...)
    destroyed: StrictBool = Field(...)
    __properties = ["hash", "lt", "account", "success", "utime", "orig_status", "end_status", "total_fees", "transaction_type", "state_update_old", "state_update_new", "in_msg", "out_msgs", "block", "prev_trans_hash", "prev_trans_lt", "compute_phase", "storage_phase", "credit_phase", "action_phase", "bounce_phase", "aborted", "destroyed"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Transaction:
        """Create an instance of Transaction from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of account
        if self.account:
            _dict['account'] = self.account.to_dict()
        # override the default output from pydantic by calling `to_dict()` of in_msg
        if self.in_msg:
            _dict['in_msg'] = self.in_msg.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in out_msgs (list)
        _items = []
        if self.out_msgs:
            for _item in self.out_msgs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['out_msgs'] = _items
        # override the default output from pydantic by calling `to_dict()` of compute_phase
        if self.compute_phase:
            _dict['compute_phase'] = self.compute_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of storage_phase
        if self.storage_phase:
            _dict['storage_phase'] = self.storage_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of credit_phase
        if self.credit_phase:
            _dict['credit_phase'] = self.credit_phase.to_dict()
        # override the default output from pydantic by calling `to_dict()` of action_phase
        if self.action_phase:
            _dict['action_phase'] = self.action_phase.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Transaction:
        """Create an instance of Transaction from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Transaction.parse_obj(obj)

        _obj = Transaction.parse_obj({
            "hash": obj.get("hash"),
            "lt": obj.get("lt"),
            "account": AccountAddress.from_dict(obj.get("account")) if obj.get("account") is not None else None,
            "success": obj.get("success"),
            "utime": obj.get("utime"),
            "orig_status": obj.get("orig_status"),
            "end_status": obj.get("end_status"),
            "total_fees": obj.get("total_fees"),
            "transaction_type": obj.get("transaction_type"),
            "state_update_old": obj.get("state_update_old"),
            "state_update_new": obj.get("state_update_new"),
            "in_msg": Message.from_dict(obj.get("in_msg")) if obj.get("in_msg") is not None else None,
            "out_msgs": [Message.from_dict(_item) for _item in obj.get("out_msgs")] if obj.get("out_msgs") is not None else None,
            "block": obj.get("block"),
            "prev_trans_hash": obj.get("prev_trans_hash"),
            "prev_trans_lt": obj.get("prev_trans_lt"),
            "compute_phase": ComputePhase.from_dict(obj.get("compute_phase")) if obj.get("compute_phase") is not None else None,
            "storage_phase": StoragePhase.from_dict(obj.get("storage_phase")) if obj.get("storage_phase") is not None else None,
            "credit_phase": CreditPhase.from_dict(obj.get("credit_phase")) if obj.get("credit_phase") is not None else None,
            "action_phase": ActionPhase.from_dict(obj.get("action_phase")) if obj.get("action_phase") is not None else None,
            "bounce_phase": obj.get("bounce_phase"),
            "aborted": obj.get("aborted"),
            "destroyed": obj.get("destroyed")
        })
        return _obj

