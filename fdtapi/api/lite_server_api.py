# coding: utf-8

"""
    REST api to TON blockchain explorer

    Provide access to indexed TON blockchain  # noqa: E501

    The version of the OpenAPI document: 2.0.0
    Contact: support@tonkeeper.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Optional

from fdtapi.models.get_all_raw_shards_info200_response import GetAllRawShardsInfo200Response
from fdtapi.models.get_raw_account_state200_response import GetRawAccountState200Response
from fdtapi.models.get_raw_block_proof200_response import GetRawBlockProof200Response
from fdtapi.models.get_raw_blockchain_block200_response import GetRawBlockchainBlock200Response
from fdtapi.models.get_raw_blockchain_block_header200_response import GetRawBlockchainBlockHeader200Response
from fdtapi.models.get_raw_blockchain_block_state200_response import GetRawBlockchainBlockState200Response
from fdtapi.models.get_raw_config200_response import GetRawConfig200Response
from fdtapi.models.get_raw_list_block_transactions200_response import GetRawListBlockTransactions200Response
from fdtapi.models.get_raw_masterchain_info200_response import GetRawMasterchainInfo200Response
from fdtapi.models.get_raw_masterchain_info_ext200_response import GetRawMasterchainInfoExt200Response
from fdtapi.models.get_raw_shard_block_proof200_response import GetRawShardBlockProof200Response
from fdtapi.models.get_raw_shard_info200_response import GetRawShardInfo200Response
from fdtapi.models.get_raw_time200_response import GetRawTime200Response
from fdtapi.models.get_raw_transactions200_response import GetRawTransactions200Response
from fdtapi.models.send_raw_message200_response import SendRawMessage200Response
from fdtapi.models.send_raw_message_request import SendRawMessageRequest

from fdtapi.api_client import ApiClient
from fdtapi.api_response import ApiResponse
from fdtapi.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class LiteServerApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_all_raw_shards_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> GetAllRawShardsInfo200Response:  # noqa: E501
        """get_all_raw_shards_info  # noqa: E501

        Get all raw shards info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_raw_shards_info(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetAllRawShardsInfo200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_all_raw_shards_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_all_raw_shards_info_with_http_info(block_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_all_raw_shards_info_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_all_raw_shards_info  # noqa: E501

        Get all raw shards info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_raw_shards_info_with_http_info(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetAllRawShardsInfo200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_raw_shards_info" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetAllRawShardsInfo200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_all_shards_info/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_account_state(self, account_id : Annotated[StrictStr, Field(..., description="account ID")], **kwargs) -> GetRawAccountState200Response:  # noqa: E501
        """get_raw_account_state  # noqa: E501

        Get raw account state  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_account_state(account_id, async_req=True)
        >>> result = thread.get()

        :param account_id: account ID (required)
        :type account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawAccountState200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_account_state_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_account_state_with_http_info(account_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_account_state_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="account ID")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_account_state  # noqa: E501

        Get raw account state  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_account_state_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param account_id: account ID (required)
        :type account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawAccountState200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_account_state" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['account_id'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawAccountState200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_account_state/{account_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_block_proof(self, known_block : Annotated[StrictStr, Field(..., description="known block: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], target_block : Annotated[Optional[StrictStr], Field(description="target block: (workchain,shard,seqno,root_hash,file_hash)")] = None, **kwargs) -> GetRawBlockProof200Response:  # noqa: E501
        """get_raw_block_proof  # noqa: E501

        Get raw block proof  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_block_proof(known_block, mode, target_block, async_req=True)
        >>> result = thread.get()

        :param known_block: known block: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type known_block: str
        :param mode: mode (required)
        :type mode: int
        :param target_block: target block: (workchain,shard,seqno,root_hash,file_hash)
        :type target_block: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawBlockProof200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_block_proof_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_block_proof_with_http_info(known_block, mode, target_block, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_block_proof_with_http_info(self, known_block : Annotated[StrictStr, Field(..., description="known block: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], target_block : Annotated[Optional[StrictStr], Field(description="target block: (workchain,shard,seqno,root_hash,file_hash)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_block_proof  # noqa: E501

        Get raw block proof  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_block_proof_with_http_info(known_block, mode, target_block, async_req=True)
        >>> result = thread.get()

        :param known_block: known block: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type known_block: str
        :param mode: mode (required)
        :type mode: int
        :param target_block: target block: (workchain,shard,seqno,root_hash,file_hash)
        :type target_block: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawBlockProof200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'known_block',
            'mode',
            'target_block'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_block_proof" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('known_block') is not None:  # noqa: E501
            _query_params.append(('known_block', _params['known_block']))

        if _params.get('target_block') is not None:  # noqa: E501
            _query_params.append(('target_block', _params['target_block']))

        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawBlockProof200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_block_proof', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_blockchain_block(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> GetRawBlockchainBlock200Response:  # noqa: E501
        """get_raw_blockchain_block  # noqa: E501

        Get raw blockchain block  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_blockchain_block(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawBlockchainBlock200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_blockchain_block_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_blockchain_block_with_http_info(block_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_blockchain_block_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_blockchain_block  # noqa: E501

        Get raw blockchain block  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_blockchain_block_with_http_info(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawBlockchainBlock200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_blockchain_block" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawBlockchainBlock200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_block/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_blockchain_block_header(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], **kwargs) -> GetRawBlockchainBlockHeader200Response:  # noqa: E501
        """get_raw_blockchain_block_header  # noqa: E501

        Get raw blockchain block header  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_blockchain_block_header(block_id, mode, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param mode: mode (required)
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawBlockchainBlockHeader200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_blockchain_block_header_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_blockchain_block_header_with_http_info(block_id, mode, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_blockchain_block_header_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_blockchain_block_header  # noqa: E501

        Get raw blockchain block header  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_blockchain_block_header_with_http_info(block_id, mode, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param mode: mode (required)
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawBlockchainBlockHeader200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id',
            'mode'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_blockchain_block_header" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawBlockchainBlockHeader200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_block_header/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_blockchain_block_state(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> GetRawBlockchainBlockState200Response:  # noqa: E501
        """get_raw_blockchain_block_state  # noqa: E501

        Get raw blockchain block state  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_blockchain_block_state(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawBlockchainBlockState200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_blockchain_block_state_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_blockchain_block_state_with_http_info(block_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_blockchain_block_state_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_blockchain_block_state  # noqa: E501

        Get raw blockchain block state  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_blockchain_block_state_with_http_info(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawBlockchainBlockState200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_blockchain_block_state" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawBlockchainBlockState200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_state/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_config(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], **kwargs) -> GetRawConfig200Response:  # noqa: E501
        """get_raw_config  # noqa: E501

        Get raw config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_config(block_id, mode, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param mode: mode (required)
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawConfig200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_config_with_http_info(block_id, mode, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_config_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_config  # noqa: E501

        Get raw config  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_config_with_http_info(block_id, mode, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param mode: mode (required)
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawConfig200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id',
            'mode'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawConfig200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_config_all/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_list_block_transactions(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], count : Annotated[StrictInt, Field(..., description="count")], account_id : Annotated[Optional[StrictStr], Field(description="account ID")] = None, lt : Annotated[Optional[StrictInt], Field(description="lt")] = None, **kwargs) -> GetRawListBlockTransactions200Response:  # noqa: E501
        """get_raw_list_block_transactions  # noqa: E501

        Get raw list block transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_list_block_transactions(block_id, mode, count, account_id, lt, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param mode: mode (required)
        :type mode: int
        :param count: count (required)
        :type count: int
        :param account_id: account ID
        :type account_id: str
        :param lt: lt
        :type lt: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawListBlockTransactions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_list_block_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_list_block_transactions_with_http_info(block_id, mode, count, account_id, lt, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_list_block_transactions_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], mode : Annotated[StrictInt, Field(..., description="mode")], count : Annotated[StrictInt, Field(..., description="count")], account_id : Annotated[Optional[StrictStr], Field(description="account ID")] = None, lt : Annotated[Optional[StrictInt], Field(description="lt")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_list_block_transactions  # noqa: E501

        Get raw list block transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_list_block_transactions_with_http_info(block_id, mode, count, account_id, lt, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param mode: mode (required)
        :type mode: int
        :param count: count (required)
        :type count: int
        :param account_id: account ID
        :type account_id: str
        :param lt: lt
        :type lt: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawListBlockTransactions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id',
            'mode',
            'count',
            'account_id',
            'lt'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_list_block_transactions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('account_id') is not None:  # noqa: E501
            _query_params.append(('account_id', _params['account_id']))

        if _params.get('lt') is not None:  # noqa: E501
            _query_params.append(('lt', _params['lt']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawListBlockTransactions200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/list_block_transactions/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_masterchain_info(self, **kwargs) -> GetRawMasterchainInfo200Response:  # noqa: E501
        """get_raw_masterchain_info  # noqa: E501

        Get raw masterchain info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_masterchain_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawMasterchainInfo200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_masterchain_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_masterchain_info_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_masterchain_info_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_masterchain_info  # noqa: E501

        Get raw masterchain info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_masterchain_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawMasterchainInfo200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_masterchain_info" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawMasterchainInfo200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_masterchain_info', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_masterchain_info_ext(self, mode : Annotated[StrictInt, Field(..., description="mode")], **kwargs) -> GetRawMasterchainInfoExt200Response:  # noqa: E501
        """get_raw_masterchain_info_ext  # noqa: E501

        Get raw masterchain info ext  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_masterchain_info_ext(mode, async_req=True)
        >>> result = thread.get()

        :param mode: mode (required)
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawMasterchainInfoExt200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_masterchain_info_ext_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_masterchain_info_ext_with_http_info(mode, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_masterchain_info_ext_with_http_info(self, mode : Annotated[StrictInt, Field(..., description="mode")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_masterchain_info_ext  # noqa: E501

        Get raw masterchain info ext  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_masterchain_info_ext_with_http_info(mode, async_req=True)
        >>> result = thread.get()

        :param mode: mode (required)
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawMasterchainInfoExt200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'mode'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_masterchain_info_ext" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('mode') is not None:  # noqa: E501
            _query_params.append(('mode', _params['mode']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawMasterchainInfoExt200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_masterchain_info_ext', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_shard_block_proof(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> GetRawShardBlockProof200Response:  # noqa: E501
        """get_raw_shard_block_proof  # noqa: E501

        Get raw shard block proof  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_shard_block_proof(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawShardBlockProof200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_shard_block_proof_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_shard_block_proof_with_http_info(block_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_shard_block_proof_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_shard_block_proof  # noqa: E501

        Get raw shard block proof  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_shard_block_proof_with_http_info(block_id, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawShardBlockProof200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_shard_block_proof" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawShardBlockProof200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_shard_block_proof/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_shard_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], workchain : Annotated[StrictInt, Field(..., description="workchain")], shard : Annotated[StrictInt, Field(..., description="shard")], exact : Annotated[StrictBool, Field(..., description="exact")], **kwargs) -> GetRawShardInfo200Response:  # noqa: E501
        """get_raw_shard_info  # noqa: E501

        Get raw shard info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_shard_info(block_id, workchain, shard, exact, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param workchain: workchain (required)
        :type workchain: int
        :param shard: shard (required)
        :type shard: int
        :param exact: exact (required)
        :type exact: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawShardInfo200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_shard_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_shard_info_with_http_info(block_id, workchain, shard, exact, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_shard_info_with_http_info(self, block_id : Annotated[StrictStr, Field(..., description="block ID: (workchain,shard,seqno,root_hash,file_hash)")], workchain : Annotated[StrictInt, Field(..., description="workchain")], shard : Annotated[StrictInt, Field(..., description="shard")], exact : Annotated[StrictBool, Field(..., description="exact")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_shard_info  # noqa: E501

        Get raw shard info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_shard_info_with_http_info(block_id, workchain, shard, exact, async_req=True)
        >>> result = thread.get()

        :param block_id: block ID: (workchain,shard,seqno,root_hash,file_hash) (required)
        :type block_id: str
        :param workchain: workchain (required)
        :type workchain: int
        :param shard: shard (required)
        :type shard: int
        :param exact: exact (required)
        :type exact: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawShardInfo200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'block_id',
            'workchain',
            'shard',
            'exact'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_shard_info" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['block_id']:
            _path_params['block_id'] = _params['block_id']


        # process the query parameters
        _query_params = []
        if _params.get('workchain') is not None:  # noqa: E501
            _query_params.append(('workchain', _params['workchain']))

        if _params.get('shard') is not None:  # noqa: E501
            _query_params.append(('shard', _params['shard']))

        if _params.get('exact') is not None:  # noqa: E501
            _query_params.append(('exact', _params['exact']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawShardInfo200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_shard_info/{block_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_time(self, **kwargs) -> GetRawTime200Response:  # noqa: E501
        """get_raw_time  # noqa: E501

        Get raw time  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_time(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawTime200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_time_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_time_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_time_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_time  # noqa: E501

        Get raw time  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_time_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawTime200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_time" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawTime200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_time', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_raw_transactions(self, account_id : Annotated[StrictStr, Field(..., description="account ID")], count : Annotated[StrictInt, Field(..., description="count")], lt : Annotated[StrictInt, Field(..., description="lt")], hash : Annotated[StrictStr, Field(..., description="hash")], **kwargs) -> GetRawTransactions200Response:  # noqa: E501
        """get_raw_transactions  # noqa: E501

        Get raw transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_transactions(account_id, count, lt, hash, async_req=True)
        >>> result = thread.get()

        :param account_id: account ID (required)
        :type account_id: str
        :param count: count (required)
        :type count: int
        :param lt: lt (required)
        :type lt: int
        :param hash: hash (required)
        :type hash: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetRawTransactions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_raw_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_raw_transactions_with_http_info(account_id, count, lt, hash, **kwargs)  # noqa: E501

    @validate_arguments
    def get_raw_transactions_with_http_info(self, account_id : Annotated[StrictStr, Field(..., description="account ID")], count : Annotated[StrictInt, Field(..., description="count")], lt : Annotated[StrictInt, Field(..., description="lt")], hash : Annotated[StrictStr, Field(..., description="hash")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_raw_transactions  # noqa: E501

        Get raw transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_raw_transactions_with_http_info(account_id, count, lt, hash, async_req=True)
        >>> result = thread.get()

        :param account_id: account ID (required)
        :type account_id: str
        :param count: count (required)
        :type count: int
        :param lt: lt (required)
        :type lt: int
        :param hash: hash (required)
        :type hash: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetRawTransactions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_id',
            'count',
            'lt',
            'hash'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_raw_transactions" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['account_id'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('lt') is not None:  # noqa: E501
            _query_params.append(('lt', _params['lt']))

        if _params.get('hash') is not None:  # noqa: E501
            _query_params.append(('hash', _params['hash']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetRawTransactions200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/get_transactions/{account_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def send_raw_message(self, send_raw_message_request : Annotated[SendRawMessageRequest, Field(..., description="Data that is expected")], **kwargs) -> SendRawMessage200Response:  # noqa: E501
        """send_raw_message  # noqa: E501

        Send raw message to blockchain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_raw_message(send_raw_message_request, async_req=True)
        >>> result = thread.get()

        :param send_raw_message_request: Data that is expected (required)
        :type send_raw_message_request: SendRawMessageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SendRawMessage200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the send_raw_message_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.send_raw_message_with_http_info(send_raw_message_request, **kwargs)  # noqa: E501

    @validate_arguments
    def send_raw_message_with_http_info(self, send_raw_message_request : Annotated[SendRawMessageRequest, Field(..., description="Data that is expected")], **kwargs) -> ApiResponse:  # noqa: E501
        """send_raw_message  # noqa: E501

        Send raw message to blockchain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_raw_message_with_http_info(send_raw_message_request, async_req=True)
        >>> result = thread.get()

        :param send_raw_message_request: Data that is expected (required)
        :type send_raw_message_request: SendRawMessageRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SendRawMessage200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'send_raw_message_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_raw_message" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['send_raw_message_request'] is not None:
            _body_params = _params['send_raw_message_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SendRawMessage200Response",
        }

        return self.api_client.call_api(
            '/v2/liteserver/send_message', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
